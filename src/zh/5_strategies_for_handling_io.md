# 处理I/O的策略

在我们开始编写代码之前，让我们完成本书的这一部分，稍微讨论一下处理I/O和并发的不同策略。现在，只要注意我在这里总结了I/O的概念，但我以网络通信作为主要例子。不同的策略可能会根据我们讨论的I/O类型而具有不同的优势。

## 1. 使用操作系统线程

现在，实现这一目标的一种方法是让操作系统为我们处理一切。我们可以通过为要完成的每个任务生成一个新的操作系统线程，并编写与通常相同的代码来实现这一点。

**Pros:**

- 简单
- 编码容易
- 性能合理
- 免费获得并行性

**Cons:**

- 操作系统级别的线程具有相当大的堆栈。如果同时有许多任务等待（就像在负载很重的Web服务器下），您很快就会耗尽内存。
- 涉及许多系统调用。当任务数量很多时，这可能会非常昂贵。
- 操作系统有许多事情需要处理。它可能不会像您希望的那样快速切换回您的线程。
- 操作系统不知道要优先处理哪些任务，您可能希望给某些任务比其他任务更高的优先级。

## 2. 绿色线程

另一种常见的处理方式是绿色线程。像Go这样的语言就是很成功地使用了这种方法。在许多方面，这与操作系统的处理方式相似，但运行时可以更好地调整和适应您的特定需求。

**Pros:**

- 对用户来说使用简单。代码看起来与使用操作系统线程时一样
- 性能合理
- 大量内存使用不太成问题
- 您完全控制线程的调度方式，如果需要，可以以不同的优先级对它们进行调度

**Cons:**

- 您需要一个运行时，这样做会重复操作系统已经完成的部分工作。运行时将会产生一定的成本，在某些情况下可能是相当可观的。
- 在灵活处理各种任务方面可能会很难实现

## 3. 由操作系统支持的基于轮询的事件循环

今天我们要讨论的第三种方式是最接近理想解决方案的一种。在这种解决方案中，我们注册对事件的兴趣，然后让操作系统告诉我们何时准备好了。

这种工作方式是，我们告诉操作系统我们对网络卡上的数据到达时感兴趣。当发生某些事件时，网络卡会发出中断，驱动程序会通知操作系统数据已准备就绪。

现在，我们仍然需要一种方式在等待期间“挂起”许多任务，这就是 Nodes "runtime" 或 Rust 的 Futures 起作用的地方。

**Pros:**

- 接近最佳资源利用率
- 非常高效
- 给予我们最大的灵活性来决定如何处理发生的事件
**Cons:**

- 不同的操作系统处理这种类型的队列的方式不同。其中一些很难彼此协调。一些操作系统对支持此方法的I/O操作有限制。
- 出色的灵活性伴随着相当多的复杂性。
- 很难编写一个抽象层，能够考虑到操作系统之间的差异而不引入不必要的成本，并同时提供人性化的API。
- 只解决了问题的一部分，程序员仍然需要一种策略来挂起正在等待的任务。

## 最后请注意

Node.js运行时结合了1和3的组合，但试图强制所有I/O都使用第3种方式。这也是为什么Node.js在处理许多连接时如此出色的部分原因。Node.js使用基于回调的方法来挂起任务。

Rust的异步编程故事围绕着选项3展开，它花了很长时间的一些原因与这种方法的缺点以及选择如何建模任务挂起的方式有关。Rust的Futures模型将任务建模为[状态机](https://en.wikipedia.org/wiki/Finite-state_machine)，其中挂起点表示一个state。
